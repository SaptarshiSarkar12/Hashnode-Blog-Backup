---
title: "Everything You Need to Know About Binary Search"
seoTitle: "Binary Search Explained: A Comprehensive Guide"
seoDescription: "Learn binary search algorithm with this comprehensive guide on its principles, applications, and how it compares to other search methods"
slug: everything-you-need-to-know-about-binary-search
tags: dsa, binary-search-algorithm, java, search-algorithms, leetcode

---

Binary search is a cornerstone of efficient searching techniques, particularly when dealing with large datasets. Its power lies in its ability to drastically cut down the number of comparisons needed to locate an element, thanks to its **divide-and-conquer** approach. This article will guide you through the principles of binary search, its practical applications, and how it stands out from other search algorithms.

## What is Binary Search?

Binary Search is an efficient algorithm used to find the position of a target element in a **sorted array**. It works by repeatedly **dividing the search space in half**, significantly reducing the number of comparisons required.

## How does it work?

Suppose we have a sequence of **N elements** stored in an array. If the sequence is **unsorted**, the standard approach is to examine every element one by one until we either find the target or reach the end of the dataset. This method is commonly known as [**Linear Search**](https://saptarshisarkar.hashnode.dev/mastering-linear-search) (or Sequential Search).

When the sequence is sorted, a more efficient **binary search** algorithm can be used.  
If we consider an arbitrary element in a sequence sorted in increasing order with the value **m**, we can be sure that all elements prior to that have values *less than or equal to* ***m***, and all elements after it have values *greater than or equal to* ***m***. Now, the search area is divided into **two parts** and based on the **target number** (the one we're looking for), we can choose to search in one of these regions.

Let‚Äôs consider the array below for a deeper understanding of its working.

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1754414618652/2c7f7444-74c0-4aca-81f0-f82633e1a3d3.png align="center")

Suppose we need to look for the **number 81**.

Let `start` and `end` represent start and end indices initially set to `0` and `n-1` (where `n` is the size of the array) respectively.

First the algorithm will find the middle element of the array. Let `m` represent the index of the middle element of the array. Then `m` will be the integral value of half of the sum of start and end indices.  
Mathematically, we can write üëá

$$m = floor(\frac{start + end}{2})$$

Then comes three cases,

1. If the target equals the middle element, then we have found the item we‚Äôre looking for and we return it.
    
2. If the target element is less than the middle element, then we‚Äôll need to search again in the first half of the array (i.e. left side of the middle element) as the array is in ascending order.
    
3. If the target element is greater than the middle element, then we‚Äôll need to search again in the second half of the array (i.e. right side of the middle element).
    

In the example, `start` corresponds to `0` index and `end` corresponds to index `7`. So, `m` will be `3`.

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1757503966410/2ae5b29e-4bca-4f0f-a491-25ed163103dd.png align="center")

In the first iteration, as 61 is less than our target element 81, we‚Äôll need to search in the right side of 61. So, now our search space will become üëá

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1757504439616/ae166fa8-690e-4087-a8c5-66e1600a40cc.png align="center")

`start` will become `4` (because we‚Äôve already checked that **61 is not equal to 81**). Now, `m` will become `5`.

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1757504550993/485448b4-1525-4ac2-9d65-8faf8a4945af.png align="center")

The middle element, 81, is equal to the target element. Therefore, the loop will stop here, returning the index of the target element in the array.

## Time Complexity

We have two scenarios here ‚Äî the best case and the worst cases.

### Best Case

Let's say we have an array where the middle element is the same as the target. In this case, the algorithm will make just one comparison, which is the best-case scenario. So, the time complexity in this case will be **O(1)**.

### Worst Case

Suppose we have an array with **N elements** where the target element is not present. So, the algorithm will proceed as follows:

The algorithm will first find the middle element of the entire array. Let‚Äôs say that the target element is greater than the middle element, so the search space will be reduced to **N/2** (right side of the middle element).

Again, suppose the target element is to the left of the new middle element. The search space will then shrink to **N/4**, then to **N/8**, and so on. Eventually, only one element will remain, making the final search space **1**. That last element will either match the target element, or it won't, both being worst-case scenarios.

We can visualize the number of comparisons made in each iteration using the following diagram. Let the Kth comparison be the last one.

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1757653025436/37322343-d461-4d95-b22d-63aae4c33b15.png align="center")

For the **0th comparison**, the search space is **N** which can be written as \\(\frac{N}{2^0}\\).

For **1st comparison**, **N/2** can be written as \\(\frac{N}{2^1}\\).

Similarly, **N/4** can be written as \\(\frac{N}{2^4}\\).

and so on. Following the same pattern, we can write **1** as \\(\frac{N}{2^k}\\)

Therefore,

$$N = 2^k$$

Taking \\(log\\) on both sides,

$$\begin{align} log\ N = log\ 2^k \\ \Rightarrow log\ N = k\ *\ log\ 2 \\ \therefore k = log_{2}\ (N) \end{align}$$

Hence, total number of comparisons in the worst-case scenario is \\(log\ N\\). So, the time complexity is **O(log N)**.

## Example Code

An example code in Java is shown below.

We cannot use the \\(mid = \frac{start\ +\ end}{2}\\) formula because `int` has a **fixed size limit**, and the value of `start + end` may **exceed** the maximum value supported by `int`. Therefore, we use the safer alternative:

$$mid = start\ +\ \frac{end\ -\ start}{2}$$

```java
public class Main {
    public static void main(String[] args) {
        int[] arr = {-87, -58, -23, 2, 5, 63, 94, 99, 135, 189};
        int target = 94;
        int index = binarySearch(arr, target);
        System.out.println("Index of " + target + " is " + index);
    }

    // return the index
    // return -1 if the element does not exist
    static int binarySearch(int[] arr, int target) {
        int start = 0;
        int end = arr.length - 1;

        while (start <= end) {
            int middle = start + (end - start) / 2;
            if (target < arr[middle]) {
                end = middle - 1;
            } else if (target > arr[middle]) {
                start = middle + 1;
            } else {
                return middle;
            }
        }
        return -1;
    }
}
```

## Order Agnostic Binary Search

Currently, we have assumed that the array is sorted in ascending order. Now, we will explore an order-agnostic binary search algorithm. This algorithm first checks the order of the sorted array and then performs the search accordingly. Time complexity will remain the same.

The simplest way to check the order of the array is to check the first and the last elements of the array and compare between them.

### Example Code

Here‚Äôs a sample code for order agnostic binary search algorithm:

```java
public class OrderAgnosticBS {
    public static void main(String[] args) {
        int[] arr1 = {-87, -58, -23, 2, 5, 63, 94, 99, 135, 189};
        int[] arr2 = {157, 100, 65, 52, 37, 24, 18, -4, -36, -58, -88};
        int target1 = 94;
        int target2 = 65;
        int index1 = orderAgnosticBS(arr1, target1);
        System.out.println("[arr1]:  Index of " + target1 + " is " + index1);
        int index2 = orderAgnosticBS(arr2, target2);
        System.out.println("[arr2]: Index of " + target2 + " is " + index2);
    }

    static int orderAgnosticBS(int[] arr, int target) {
        int start = 0;
        int end = arr.length - 1;

        // find whether the array is sorted in ascending or descending order
        boolean isAscending = arr[start] < arr[end];

        while (start <= end) {
//            int middle = (start + end) / 2; // The value "start + end" might exceed the maximum possible integer value
            int middle = start + (end - start) / 2;

            if (arr[middle] == target) {
                return middle;
            }

            if (isAscending) {
                if (target < arr[middle]) {
                    end = middle - 1;
                } else {
                    start = middle + 1;
                }
            } else {
                if (target > arr[middle]) {
                    end = middle - 1;
                } else {
                    start = middle + 1;
                }
            }
        }
        return -1;
    }
}
```

## Conclusion

I hope this article has provided you with a clear understanding of binary search and its significance in efficient data searching. Whether you're a beginner or an experienced programmer, mastering binary search can greatly enhance your problem-solving skills and optimize your algorithms. Keep exploring and practicing harnessing the full potential of this fundamental algorithm in your coding journey. Thank you for reading, and happy coding!

‚≠ê Check out the [**DSA**](https://github.com/SaptarshiSarkar12/DSA) GitHub repo for more code examples.